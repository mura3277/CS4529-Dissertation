#Cython Imports
import cython_dtype
import cython_cloop
import cython_indexing
import cython_views
import cython_raw
import cython_dict
import cython_inter

#Imports for execution profiling
import io
import time
import pstats
import cProfile
import re
from pstats import SortKey
import matplotlib.pyplot as plt
import datetime
from pycallgraph2 import PyCallGraph
from pycallgraph2.output import GraphvizOutput

#Imports for formatting ray array
from enum import Enum, auto
from numpy import array, zeros, arange, where, ndarray

#Imports for calculating interfunction
from numpy import cross, dot, multiply, NaN

#Keep track of the final profiled data with an list of dictionaries
profiled_runs = []

#Helper Enum class for keeping track and switching between optimisation trategies
class SolutionType(Enum):
    #Solutions: Format Ray Array
    ORIG_FORMAT = auto() #Original code to maintain baseline testing
    NO_LIST_COMP = auto() #Avoid using Python list comp
    CHAT_GPT_CODE = auto() #Solution generated by ChatGPT
    INIT_NP_ARRAY = auto() #Initialize NP array with correct sizing
    CYTHON_DTYPE = auto() #Use C style type hinting
    CYTHON_INDEXING = auto() #Cache indexing into arrays
    CYTHON_VIEWS = auto() #Memory views instead of arrays
    CYTHON_RAW = auto() #Using malloc to access raw byes
    CYTHON_DICT = auto() #Cache dictionary lookups
    CYTHON_CLOOP = auto()  #Use C style loops instead of list comp

    #Solutions: Interfunction
    ORIG_INTER = auto()
    NO_SELF_INTER = auto()
    CYTHON_INTER = auto()

#Global initial format type
global SOLUTIONS

#Helper for accessing the global SOLUTIONS from other files
def solution_active(solution):
    global SOLUTIONS
    return solution in SOLUTIONS

#Run a python function with profiling output for every passed iteration
def run_func_profiled(func_to_run, iterations, solutions, graph=False):
    #Access global variable and assign it
    global SOLUTIONS
    SOLUTIONS = solutions

    #If generating the call graph, run the simulation with no profiling
    if graph:
        with PyCallGraph(output=GraphvizOutput()):
            func_to_run()
    #Otherwise run profiling as usual
    else:
        #Iteration loop
        for i in range(iterations):
            pr = cProfile.Profile()
            pr.enable()
            start = time.time()
            func_to_run()
            end = time.time()
            pr.disable()
            s = io.StringIO()
            ps = pstats.Stats(pr, stream=s).sort_stats(SortKey.TIME)
            ps.print_stats()
            lines = format_profile_output_str(s.getvalue(), end - start)
            profiled_runs.append({"solutions":[s.name for s in solutions], "elapsed": end - start, "lines": lines})
            for l in lines:
                print(l)

#Format the profiling output
def format_profile_output_str(output_str, elapsed):
    #Cut off the first few lines and ignore lines past 25
    lines = output_str.split("\n")[4:25]
    for i in range(len(lines)):
        #Trim whitespace prefix
        lines[i] = lines[i][3:]
    #Finally reinsert
    lines.insert(0, "Total Elapsed Time: " + str(elapsed))
    return lines

#Optimising formatting the output ray array using an idx lookup.
def format_ray_array(rays, idx):
    #The original version of the code
    if SolutionType.ORIG_FORMAT in SOLUTIONS:
        # This line contributed to over 40 seconds of the 79 second run that was profiled during testing.
        return array([(rays[:, idx[-1][0][c], idx[-1][1][c]]) for c in range(len(idx[-1][0]))])
    #Solution generated by ChatGPT
    elif SolutionType.CHAT_GPT_CODE in SOLUTIONS:
        last_idx = idx[-1]  # Store the last element of idx for better readability
        rows, cols = last_idx[0], last_idx[1]  # Extract the row and column indices
        result = rays[:, rows, cols]  # Extract the desired elements using the indices
        # If necessary, convert the result to an array
        if not isinstance(result, ndarray):
            result = np.array(result)
        return result
    #Removing the use of list comprehension as this can be a slow operation in Python
    elif SolutionType.NO_LIST_COMP in SOLUTIONS:
        formatted = []
        for c in range(len(idx[-1][0])):
            formatted.append(rays[:, idx[-1][0][c], idx[-1][1][c]])
        numpyArray = array(formatted)
        return numpyArray
    #Initially generating a numpy array with the correct size and shape, then assigning values by index
    elif SolutionType.INIT_NP_ARRAY in SOLUTIONS:
        formatted = zeros((len(idx[-1][0]), 3))
        for c in range(len(idx[-1][0])):
            formatted[c] = rays[:, idx[-1][0][c], idx[-1][1][c]]
        return formatted
    #Offload the array formatting to a compiled C binary
    elif SolutionType.CYTHON_DTYPE in SOLUTIONS:
        formatted = cython_dtype.run(rays, idx)
        return formatted
    elif SolutionType.CYTHON_INDEXING in SOLUTIONS:
        formatted = cython_indexing.run(rays, idx)
        return formatted
    elif SolutionType.CYTHON_VIEWS in SOLUTIONS:
        formatted = cython_views.run(rays, idx)
        return formatted
    elif SolutionType.CYTHON_RAW in SOLUTIONS:
        formatted = cython_raw.run(rays, idx)
        return formatted
    elif SolutionType.CYTHON_DICT in SOLUTIONS:
        formatted = cython_dict.run(rays, idx)
        return formatted
    elif SolutionType.CYTHON_CLOOP in SOLUTIONS:
        formatted = cython_cloop.run(rays, idx)
        return formatted

#Alternate Interfunction designed to not use the self keyword
def calc_interfunction(rays, pov, p1, v, u):
    #Only run if NO_SELF_INTER solution is used
    if SolutionType.NO_SELF_INTER in SOLUTIONS:
        rshape = rays.shape[1:]  # Shape of the 2D array of rays
        rays = rays.reshape((3, rays.shape[1] * rays.shape[2])).T  # Reshapes into a 2D array of vectors.
        epsilon = 1e-6
        T = pov - p1  # Vector from p1 to pov (tvec)
        P = cross(rays, v.reshape((1, 3)))  # Cross product of ray and v (pvec)
        S = dot(P, u)  # Dot product of pvec and u (determinant).
        inv_det = where(abs(S) > epsilon, 1 / S, NaN)  # Inverse determinant
        U = multiply(dot(P, T), inv_det)  # Barycentric coordinate u
        # try to whittle down the number of calculations
        if True in (U >= 0) & (U <= 1):  # If u is in the triangle, calculate v and t.
            Q = cross(T, u)  # Cross product of tvec and edge, u. This is constant.
            V = where((U >= 0) & (U <= 1), dot(Q, rays.transpose()), NaN) * inv_det  # Barycentric coordinate v
            t = where(((V >= 0) & (U + V <= 1)), dot(Q, v), NaN) * inv_det  # Distance to intersection point
            t = where(t <= 0, NaN, t)  # If t is negative, the intersection point is behind the pov.
            V = V.reshape(rshape)
            U = U.reshape(rshape)
            t = t.reshape(rshape)
            return U, V, t
        else:
            return None, None, None
    #Or run the CYTHON_INTER solution instead
    elif SolutionType.CYTHON_INTER in SOLUTIONS:
        return cython_inter.run(rays, pov, p1, v, u)

#Compile results into visual graphs
def graph_and_log_profiled_solutions():
    plt.rcdefaults()
    #Create figure
    fig, ax = plt.subplots()

    #Format the data to be suitable for graphs
    run_title = []
    performance = []
    total_time = 0.0
    for r in profiled_runs:
        run_title.append(str(r["solutions"]))
        performance.append(r["elapsed"])
        total_time += float(r["elapsed"])

    #Setup the graph orientation, labels and input data
    y_pos = arange(len(run_title))
    ax.barh(y_pos, performance, align="center")
    ax.set_yticks(y_pos, labels=run_title)
    ax.invert_yaxis()  # labels read top-to-bottom
    ax.set_xlabel("Execution speed (seconds)")
    ax.set_title("Execution speed of each profiled optimisation")

    #Generate a timestamp for the file names
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    plt.savefig("Results/" + timestamp + ".png", bbox_inches='tight')
    plt.show()

    print("Total Time For All Runs: " + str(total_time))

#Print the solutions and elapsed time from the profiled runs
def print_total_runs_and_time():
    for s in profiled_runs:
        print(s["solutions"])
        print(s["elapsed"])
